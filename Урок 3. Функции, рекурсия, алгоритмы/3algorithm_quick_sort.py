#Алгоритмом называется набор инструкций для выполнения

#Быстрая сортировка - “Программирование это разбиение чего-то большого и невозможного на что-то маленькое и вполне реальное”
# Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”. Сначала
# рассмотрим пример, затем напишем программный код
# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать.
# Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60,
# 73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
# и властвуй”

def quick_sort(list_1): # Создается функция быстрой сортировки, которая представляет собой рекурсию
    if len(list_1)<=1: # Условие выхода
        return list_1
    else:
        pivot = list_1[0]
    less = [i for i in list_1[1:] if i <=pivot]
    greater = [i for i in list_1[1:] if i >pivot]
    return quick_sort(less)+[pivot]+quick_sort(greater) 
#При первом вызове рекурсии будет возвращаться 2 неотсортированных списка (less и greater) и значение pivot
#но так как списки неотсортированы то будет снова возвращаться quick_sort(less) и quick_sort(greater) 

print(quick_sort([14,545,3424,64,2,56,3,342,65,4,56]))
print(quick_sort([10,5,2]))

# ● 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии
# добавляется список [10]
# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5, 10]
